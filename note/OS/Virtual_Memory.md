- Virtual Memory

    虛擬記憶體是電腦系統記憶體管理的一種技術。它使得應用程式認為它擁有連續的可用的記憶體（一個連續完整的位址空間），而實際上，它通常是被分隔成多個實體記憶體碎片，還有部分暫時儲存在外部磁碟記憶體上，在需要時進行資料交換。

- why

    程式在被 CPU 執行之前，必須先把程式的內容載入到到一段 連續的記憶體空間，如此一來 CPU 才能根據記憶體中的的程式一行一行執行下去

    記憶體碎片化（Memory Fragmentation）簡單來說就是雖然剩餘的空間總合夠大，但因為那些空間被切割成大大小小的區塊，導致沒有一段足夠大的連續空間可以使用

    為了解決碎片化的問題，現在的電腦都會做 記憶體虛擬化（Memory Virtualization），也就是給每個 process 一塊獨立的虛擬記憶體（Virtual Memory），然後把他對應到可用的 實體記憶體（Physical Memory）中

- Memory Management Unit(MMU)

    雖然 記憶體虛擬化 聽起來完美解決了碎片化的問題，但如果每次程式要去存取記憶體時，作業系統都要花時間把虛擬位址（Virtual Address）轉成實體位址（Physical Address），那程式跑起來就會慢很多

    為了解決這個問題，從 1980 年代開始的電腦都會加上一塊硬體叫 MMU，根據維基的說法大概是長這樣XD

    這個 MMU 內部有一個 page table 記錄了虛擬/實體位址的對應關係，當你的程式叫 CPU 去拿一個變數，CPU 就會馬上叫 MMU 去找對應的實體位址，得到實體位址後再馬上把變數值拿給你

    因為是直接用硬體來實作，雖然還是會稍微降低效能，但跟軟體比起來已經少了很多 overhead

- extra benefit

    -   Process 間共享實體記憶體

        平常在開發時經常會用不同程式打開同一個檔案，譬如說我一邊在跑 node app.js，同時又在用 VSCode 讀 app.js 的程式碼，這時候 OS 就可以只載入一次 app.js，然後把兩個 process 的虛擬位址對應到同一塊實體記憶體

    -   不需要載入整個程式（Demand Paging）

        在有虛擬記憶體之前，要執行一個程式往往需要把整個程式載入記憶體

        但仔細想一想，每個程式都有很多地方根本不太會被執行到：譬如說有些程式碼的功能是在程式崩潰之時把 stack trace 印出來、有些則是在服務異常時發送 slack 通知給開發人員。如果這些例外狀況極少發生，那把整個程式都載入記憶體內顯然不是個好主意

    -   把用不到的東西丟出去（Swapping）

        剛剛 Demand Paging 講的是只把需要的部分載入記憶體，那萬一那些「需要的部分」很大，大到記憶體不夠用呢？這時系統就會開始做 Swapping，也就是把「曾經用過，但以後用不太到」的東西丟出去

        譬如說程式剛啟動時要跑的 init()、偶爾才跑一次的 error_handler() ，他們都曾經被執行過所以一定有被載入記憶體。但如果可用的記憶體快沒了，系統就會把他們 swap 出去（沒用的東西都給我滾），哪天需要時再從硬碟拿回來就好

        ```
        有了 swapping 機制後雖然可以增進記憶體的使用效率，而且記憶體絕對不會不夠用（說穿了就是拿硬碟當擴充記憶體），但因為硬碟速度很慢，所以若是系統很頻繁的做 swapping 就會導致效能變差（因為 CPU 一直在等硬碟讀寫）

        那怎麼知道系統用了多少 Swap 呢？看 htop 就可以了。我的 htop 打開後會看到 Swp 是 0/1023MB，意思是系統沒有把任何記憶體 swap 到硬碟上（因為我的 Mem 還夠用），但如果需要的話最多可以把 1023MB 的記憶體 swap 出去，等需要時再拿回來就好
        ```